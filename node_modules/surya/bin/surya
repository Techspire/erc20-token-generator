#!/usr/bin/env node
const fs = require('fs');
const colors = require('colors');
const { describe, graph, graphSimple, inheritance, dependenciesPrint, flatten, parse, ftrace, mdreport } = require('../lib/index');

require('yargs') // eslint-disable-line
  .usage('$0 <cmd> [args]')
  .command('describe <files..>', 'show file contracts structure.', (yargs) => {
    yargs
      .positional('files', {
        describe: 'files to analyze',
        type: 'string'
      })
      .option('i', {
        alias: 'import',
        type: 'boolean',
        default: undefined,
        conflicts: 'c'
      })
      .option('c', {
        alias: 'content',
        type: 'boolean',
        default: undefined,
        conflicts: 'i'
      });
  }, (argv) => {
    describe(argv.files, {importer: argv.i, contentsInFilePath: argv.c});
  })
  .command('graph <files..>', 'generate graph of contract function calls.', (yargs) => {
    yargs
      .positional('files', {
        describe: 'files to analyze',
        type: 'string'
      })
      .option('l', {
        alias: 'libraries',
        type: 'boolean',
        default: false
      })
      .option('m', {
        alias: 'modifiers',
        type: 'boolean',
        default: false
      })
      .option('i', {
        alias: 'import',
        type: 'boolean',
        default: undefined,
        conflicts: 'c'
      })
      .option('c', {
        alias: 'content',
        type: 'boolean',
        default: undefined,
        conflicts: 'i'
      }).option('s', {
        alias: 'simple',
        type: 'boolean',
        default: false,
      });
  }, (argv) => {
    if (argv.s) {
      console.log(graphSimple(argv.files, {importer: argv.i, libraries: argv.l, enableModifierEdges: argv.m, contentsInFilePath: argv.c}));
    } else {
      console.log(graph(argv.files, {importer: argv.i, libraries: argv.l, enableModifierEdges: argv.m, contentsInFilePath: argv.c}));
    }
  })
  .command('inheritance <files..>', 'generate graph of contract inheritance tree.', (yargs) => {
    yargs
      .positional('files', {
        describe: 'files to analyze',
        type: 'string'
      })
      .option('i', {
        alias: 'import',
        type: 'boolean',
        default: undefined,
        conflicts: 'c'
      })
      .option('c', {
        alias: 'content',
        type: 'boolean',
        default: undefined,
        conflicts: 'i'
      });
  }, (argv) => {
    console.log(inheritance(argv.files, {importer: argv.i, contentsInFilePath: argv.c}));
  })
  .command('dependencies <target_contract> <files..>', 'output a linearized list of smart contract dependencies (linerized inherited parents).', (yargs) => {
    yargs
      .positional('files', {
        describe: 'files to analyze',
        type: 'string'
      })
      .positional('target_contract', {
        describe: 'contract name to get dependency linearization',
        type: 'string'
      })
      .option('i', {
        alias: 'import',
        type: 'boolean',
        default: undefined,
        conflicts: 'c'
      })
      .option('c', {
        alias: 'content',
        type: 'boolean',
        default: undefined,
        conflicts: 'i'
      });
  }, (argv) => {
    console.log(dependenciesPrint(argv.files, argv.target_contract, {importer: argv.i, contentsInFilePath: argv.c}));
  })
  .command('flatten <files..>', 'output to a single flattened solidity file', (yargs) => {
    yargs
      .positional('files', {
        describe: 'files to flatten',
        type: 'string'
      });
  }, (argv) => {
    flatten(argv.files, argv.target_contract);
  })
  .command('parse <file>', 'output AST generated by the parser for the specified file in a textual tree format.', (yargs) => {
    yargs
      .positional('file', {
        describe: 'file to parse',
        type: 'string'
      });
  }, (argv) => {
    console.log(parse(argv.file));
  })
  .command('ftrace <function_identifier> <function_visibility_restrictor> <files..>', 'output the selected function call trace in a textual tree format. External calls are marked in `orange` and internal calls are `uncolored`.', (yargs) => {
    yargs
      .positional('function_identifier', {
        describe: 'function to traverse (e.g.: "CONTRACT::FUNCTION")',
        type: 'string'
      })
      .positional('function_visibility_restrictor', {
        describe: 'type of call to traverse [all|external|internal]',
        type: 'string',
        default: 'all'
      })
      .positional('files', {
        describe: 'files to include in the parsing',
        type: 'string'
      })
      .option('i', {
        alias: 'import',
        type: 'boolean',
        default: undefined,
        conflicts: 'c'
      })
      .option('c', {
        alias: 'content',
        type: 'boolean',
        default: undefined,
        conflicts: 'i'
      })
      .option('j', {
        alias: 'json',
        type: 'boolean',
        default: false
      });
  }, (argv) => {
    console.log(ftrace(argv.function_identifier, argv.function_visibility_restrictor, argv.files, {importer: argv.i, jsonOutput:argv.j, contentsInFilePath: argv.c}));
  })
  .command('mdreport <outfile> <infiles..>', 'output a markdown file ', (yargs) => {
    yargs
      .positional('outfile', {
        describe: 'name of the report file',
        type: 'string'
      })
      .positional('infiles', {
        describe: 'files to analyze',
        type: 'string'
      })
      .option('i', {
        alias: 'import',
        type: 'boolean',
        default: undefined,
        conflicts: 'c'
      })
      .option('c', {
        alias: 'content',
        type: 'boolean',
        default: undefined,
        conflicts: 'i'
      })
      .option('d', {
        alias: 'title-deepness',
        type: 'number',
        default: 2
      });
  }, (argv) => {
    try {
      fs.writeFileSync(argv.outfile, mdreport(argv.infiles, {importer: argv.i, deepness: argv.d, contentsInFilePath: argv.c}), {flag: 'w',});
    } catch (err) {
        console.log('Error in writing report file');
        console.log(err);
    }
  })
  .help()
  .alias('h', 'help')
  .version()
  .alias('v', 'version')
  .argv;
